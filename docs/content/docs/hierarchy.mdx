import { Callout } from "nextra/components";

# Hierarchy Injection

Injectors can form parent-child relationships, enabling modular and scoped dependency management.

## Creating Child Injectors

Two ways to create a child injector:

```ts
// Method 1: Using createChild
const parentInjector = new Injector([[PlatformService]]);
const childInjector = parentInjector.createChild([[OrderService]]);

// Method 2: Pass parent to constructor
const childInjector = new Injector([[OrderService]], parentInjector);
```

## Dependency Lookup

When a child injector can't find a dependency, it automatically looks in its parent:

```ts
const parentInjector = new Injector([[PlatformService]]);
const childInjector = parentInjector.createChild([[OrderService]]);

// PlatformService is found in parent and returned
childInjector.get(PlatformService);
```

## Controlling Lookup Behavior

Use decorators to control where dependencies are resolved:

| Decorator | Behavior |
|-----------|----------|
| `@Self()` | Only look in current injector |
| `@SkipSelf()` | Skip current, start from parent |

```ts
class ChartComponent {
  constructor(
    // Must be in current injector
    @Self() @Inject(Container) private selfContainer: Container,

    // Must be in parent injector
    @SkipSelf() @Optional(Container) private parentContainer?: Container
  ) {}
}
```

<Callout>
  Combine `@SkipSelf()` with `@Optional()` to gracefully handle cases where a parent dependency might not exist.
</Callout>
```
